import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, W as create_slot, v as validate_slots, T as assign, X as exclude_internal_props, Y as r, e as element, c as claim_element, b as children, f as detach_dev, h as attr_dev, j as add_location, l as insert_dev, Z as action_destroyer, _ as update_slot, H as transition_in, I as transition_out, $ as ClassBuilder, z as space, A as create_component, x as text, C as claim_space, D as claim_component, y as claim_text, m as append_dev, a0 as set_input_value, E as mount_component, F as listen_dev, G as set_data_dev, J as destroy_component, a1 as run_all, a2 as bubble } from './client.7e126f09.js';

/* node_modules/smelte/src/components/Ripple/Ripple.svelte generated by Svelte v3.24.0 */
const file = "node_modules/smelte/src/components/Ripple/Ripple.svelte";

function create_fragment(ctx) {
	let span;
	let span_class_value;
	let ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "z-40 " + /*$$props*/ ctx[3].class + " p-2 rounded-full flex items-center justify-center top-0 left-0 " + (/*noHover*/ ctx[0] ? "" : /*hoverClass*/ ctx[2]) + " svelte-1o8z87d");
			add_location(span, file, 15, 0, 293);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(ripple_action = /*ripple*/ ctx[1].call(null, span));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			if (!current || dirty & /*$$props, noHover, hoverClass*/ 13 && span_class_value !== (span_class_value = "z-40 " + /*$$props*/ ctx[3].class + " p-2 rounded-full flex items-center justify-center top-0 left-0 " + (/*noHover*/ ctx[0] ? "" : /*hoverClass*/ ctx[2]) + " svelte-1o8z87d")) {
				attr_dev(span, "class", span_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { color = "primary" } = $$props;
	let { noHover = false } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Ripple", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ("noHover" in $$new_props) $$invalidate(0, noHover = $$new_props.noHover);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		color,
		noHover,
		createRipple: r,
		ripple,
		hoverClass
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
		if ("noHover" in $$props) $$invalidate(0, noHover = $$new_props.noHover);
		if ("ripple" in $$props) $$invalidate(1, ripple = $$new_props.ripple);
		if ("hoverClass" in $$props) $$invalidate(2, hoverClass = $$new_props.hoverClass);
	};

	let ripple;
	let hoverClass;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 16) {
			 $$invalidate(1, ripple = r(color, true));
		}

		if ($$self.$$.dirty & /*color*/ 16) {
			 $$invalidate(2, hoverClass = `hover:bg-${color}-transLight`);
		}
	};

	$$props = exclude_internal_props($$props);
	return [noHover, ripple, hoverClass, $$props, color, $$scope, $$slots];
}

class Ripple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { color: 4, noHover: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Ripple",
			options,
			id: create_fragment.name
		});
	}

	get color() {
		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHover() {
		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHover(value) {
		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/smelte/src/components/Switch/Switch.svelte generated by Svelte v3.24.0 */
const file$1 = "node_modules/smelte/src/components/Switch/Switch.svelte";

// (64:4) <Ripple color={value && !disabled ? color : 'gray'} noHover>
function create_default_slot(ctx) {
	let div;
	let div_style_value;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", /*th*/ ctx[6]);
			attr_dev(div, "style", div_style_value = /*value*/ ctx[0] ? "left: 1.25rem" : "");
			add_location(div, file$1, 64, 6, 1952);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*th*/ 64) {
				attr_dev(div, "class", /*th*/ ctx[6]);
			}

			if (dirty & /*value*/ 1 && div_style_value !== (div_style_value = /*value*/ ctx[0] ? "left: 1.25rem" : "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(64:4) <Ripple color={value && !disabled ? color : 'gray'} noHover>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div2;
	let input;
	let t0;
	let div1;
	let div0;
	let t1;
	let ripple;
	let t2;
	let label_1;
	let t3;
	let current;
	let mounted;
	let dispose;

	ripple = new Ripple({
			props: {
				color: /*value*/ ctx[0] && !/*disabled*/ ctx[3]
				? /*color*/ ctx[2]
				: "gray",
				noHover: true,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			input = element("input");
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = space();
			create_component(ripple.$$.fragment);
			t2 = space();
			label_1 = element("label");
			t3 = text(/*label*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			input = claim_element(div2_nodes, "INPUT", { class: true, type: true });
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			claim_component(ripple.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);
			label_1 = claim_element(div2_nodes, "LABEL", { "aria-hidden": true, class: true });
			var label_1_nodes = children(label_1);
			t3 = claim_text(label_1_nodes, /*label*/ ctx[1]);
			label_1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "class", "hidden");
			attr_dev(input, "type", "checkbox");
			add_location(input, file$1, 60, 2, 1757);
			attr_dev(div0, "class", "w-full h-full absolute");
			add_location(div0, file$1, 62, 4, 1842);
			attr_dev(div1, "class", /*tr*/ ctx[5]);
			add_location(div1, file$1, 61, 2, 1821);
			attr_dev(label_1, "aria-hidden", "true");
			attr_dev(label_1, "class", /*l*/ ctx[7]);
			add_location(label_1, file$1, 69, 2, 2049);
			attr_dev(div2, "class", /*c*/ ctx[4]);
			add_location(div2, file$1, 59, 0, 1722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, input);
			set_input_value(input, /*value*/ ctx[0]);
			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div1, t1);
			mount_component(ripple, div1, null);
			append_dev(div2, t2);
			append_dev(div2, label_1);
			append_dev(label_1, t3);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[14]),
					listen_dev(input, "change", /*change_handler*/ ctx[13], false, false, false),
					listen_dev(div2, "click", /*check*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			const ripple_changes = {};

			if (dirty & /*value, disabled, color*/ 13) ripple_changes.color = /*value*/ ctx[0] && !/*disabled*/ ctx[3]
			? /*color*/ ctx[2]
			: "gray";

			if (dirty & /*$$scope, th, value*/ 2097217) {
				ripple_changes.$$scope = { dirty, ctx };
			}

			ripple.$set(ripple_changes);

			if (!current || dirty & /*tr*/ 32) {
				attr_dev(div1, "class", /*tr*/ ctx[5]);
			}

			if (!current || dirty & /*label*/ 2) set_data_dev(t3, /*label*/ ctx[1]);

			if (!current || dirty & /*l*/ 128) {
				attr_dev(label_1, "class", /*l*/ ctx[7]);
			}

			if (!current || dirty & /*c*/ 16) {
				attr_dev(div2, "class", /*c*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ripple.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ripple.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(ripple);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const trackClassesDefault = "relative w-10 h-auto z-0 rounded-full overflow-visible flex items-center justify-center";
const thumbClassesDefault = "rounded-full p-2 w-5 h-5 absolute elevation-3 duration-100";
const labelClassesDefault = "pl-2 cursor-pointer";

function instance$1($$self, $$props, $$invalidate) {
	const classesDefault = `inline-flex items-center mb-2 cursor-pointer z-10`;
	let { value = false } = $$props;
	let { label = "" } = $$props;
	let { color = "primary" } = $$props;
	let { disabled = false } = $$props;
	let { trackClasses = trackClassesDefault } = $$props;
	let { thumbClasses = thumbClassesDefault } = $$props;
	let { labelClasses = labelClassesDefault } = $$props;
	let { classes = classesDefault } = $$props;
	const cb = new ClassBuilder(classes, classesDefault);
	const trcb = new ClassBuilder(trackClasses, trackClassesDefault);
	const thcb = new ClassBuilder(thumbClasses, thumbClassesDefault);
	const lcb = new ClassBuilder(labelClasses, labelClassesDefault);

	function check() {
		if (disabled) return;
		$$invalidate(0, value = !value);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Switch", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_change_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
		if ("color" in $$new_props) $$invalidate(2, color = $$new_props.color);
		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("trackClasses" in $$new_props) $$invalidate(9, trackClasses = $$new_props.trackClasses);
		if ("thumbClasses" in $$new_props) $$invalidate(10, thumbClasses = $$new_props.thumbClasses);
		if ("labelClasses" in $$new_props) $$invalidate(11, labelClasses = $$new_props.labelClasses);
		if ("classes" in $$new_props) $$invalidate(12, classes = $$new_props.classes);
	};

	$$self.$capture_state = () => ({
		Ripple,
		ClassBuilder,
		classesDefault,
		trackClassesDefault,
		thumbClassesDefault,
		labelClassesDefault,
		value,
		label,
		color,
		disabled,
		trackClasses,
		thumbClasses,
		labelClasses,
		classes,
		cb,
		trcb,
		thcb,
		lcb,
		check,
		c,
		tr,
		th,
		l
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
		if ("color" in $$props) $$invalidate(2, color = $$new_props.color);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("trackClasses" in $$props) $$invalidate(9, trackClasses = $$new_props.trackClasses);
		if ("thumbClasses" in $$props) $$invalidate(10, thumbClasses = $$new_props.thumbClasses);
		if ("labelClasses" in $$props) $$invalidate(11, labelClasses = $$new_props.labelClasses);
		if ("classes" in $$props) $$invalidate(12, classes = $$new_props.classes);
		if ("c" in $$props) $$invalidate(4, c = $$new_props.c);
		if ("tr" in $$props) $$invalidate(5, tr = $$new_props.tr);
		if ("th" in $$props) $$invalidate(6, th = $$new_props.th);
		if ("l" in $$props) $$invalidate(7, l = $$new_props.l);
	};

	let c;
	let tr;
	let th;
	let l;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, c = cb.flush().add(classes, true, classesDefault).add($$props.class).get());

		if ($$self.$$.dirty & /*value, color, trackClasses*/ 517) {
			 $$invalidate(5, tr = trcb.flush().add("bg-gray-700", !value).add(`bg-${color}-200`, value).add(trackClasses, true, trackClassesDefault).get());
		}

		if ($$self.$$.dirty & /*thumbClasses, value, color*/ 1029) {
			 $$invalidate(6, th = thcb.flush().add(thumbClasses, true, thumbClassesDefault).add("bg-white left-0", !value).add(`bg-${color}-400`, value).get());
		}

		if ($$self.$$.dirty & /*labelClasses, disabled*/ 2056) {
			 $$invalidate(7, l = lcb.flush().add(labelClasses, true, labelClassesDefault).add("text-gray-500", disabled).add("text-gray-700", !disabled).get());
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		label,
		color,
		disabled,
		c,
		tr,
		th,
		l,
		check,
		trackClasses,
		thumbClasses,
		labelClasses,
		classes,
		change_handler,
		input_change_handler
	];
}

class Switch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			value: 0,
			label: 1,
			color: 2,
			disabled: 3,
			trackClasses: 9,
			thumbClasses: 10,
			labelClasses: 11,
			classes: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Switch",
			options,
			id: create_fragment$1.name
		});
	}

	get value() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trackClasses() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trackClasses(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get thumbClasses() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set thumbClasses(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelClasses() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelClasses(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get classes() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classes(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Switch as S };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3dpdGNoLjliOTdjMDVlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc21lbHRlL3NyYy9jb21wb25lbnRzL1JpcHBsZS9SaXBwbGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NtZWx0ZS9zcmMvY29tcG9uZW50cy9Td2l0Y2gvU3dpdGNoLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGNvbG9yID0gXCJwcmltYXJ5XCI7XG4gIGV4cG9ydCBsZXQgbm9Ib3ZlciA9IGZhbHNlO1xuICBpbXBvcnQgY3JlYXRlUmlwcGxlIGZyb20gXCIuLi9SaXBwbGUvcmlwcGxlLmpzXCI7XG5cbiAgJDogcmlwcGxlID0gY3JlYXRlUmlwcGxlKGNvbG9yLCB0cnVlKTtcbiAgJDogaG92ZXJDbGFzcyA9IGBob3ZlcjpiZy0ke2NvbG9yfS10cmFuc0xpZ2h0YDtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5yaXBwbGUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xuICB9XG48L3N0eWxlPlxuXG48c3BhblxuICB1c2U6cmlwcGxlXG4gIGNsYXNzPVwiei00MCB7JCRwcm9wcy5jbGFzc30gcC0yIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0b3AtMCBsZWZ0LTAge25vSG92ZXIgPyBcIlwiIDogaG92ZXJDbGFzc31cIj5cbiAgPHNsb3QgLz5cbjwvc3Bhbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBSaXBwbGUgZnJvbSBcIi4uL1JpcHBsZVwiO1xuXG4gIGltcG9ydCB7IENsYXNzQnVpbGRlciB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzc2VzLmpzXCI7XG5cbiAgY29uc3QgY2xhc3Nlc0RlZmF1bHQgPSBgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIG1iLTIgY3Vyc29yLXBvaW50ZXIgei0xMGA7XG4gIGNvbnN0IHRyYWNrQ2xhc3Nlc0RlZmF1bHQgPSBcInJlbGF0aXZlIHctMTAgaC1hdXRvIHotMCByb3VuZGVkLWZ1bGwgb3ZlcmZsb3ctdmlzaWJsZSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiO1xuICBjb25zdCB0aHVtYkNsYXNzZXNEZWZhdWx0ID0gXCJyb3VuZGVkLWZ1bGwgcC0yIHctNSBoLTUgYWJzb2x1dGUgZWxldmF0aW9uLTMgZHVyYXRpb24tMTAwXCI7XG4gIGNvbnN0IGxhYmVsQ2xhc3Nlc0RlZmF1bHQgPSBcInBsLTIgY3Vyc29yLXBvaW50ZXJcIjtcblxuICBleHBvcnQgbGV0IHZhbHVlID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgbGFiZWwgPSBcIlwiO1xuICBleHBvcnQgbGV0IGNvbG9yID0gXCJwcmltYXJ5XCI7XG4gIC8v0LfQtNC10YHRjCDQvNC+0LbQvdC+INC/0L7QvNC10L3Rj9GC0Ywg0YbQstC10YIg0L/QvtGB0LvQtSB0YWlsd2luZFxuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgdHJhY2tDbGFzc2VzID0gdHJhY2tDbGFzc2VzRGVmYXVsdDtcbiAgZXhwb3J0IGxldCB0aHVtYkNsYXNzZXMgPSB0aHVtYkNsYXNzZXNEZWZhdWx0O1xuICBleHBvcnQgbGV0IGxhYmVsQ2xhc3NlcyA9IGxhYmVsQ2xhc3Nlc0RlZmF1bHQ7XG5cblxuICBleHBvcnQgbGV0IGNsYXNzZXMgPSBjbGFzc2VzRGVmYXVsdDtcblxuXG4gIGNvbnN0IGNiID0gbmV3IENsYXNzQnVpbGRlcihjbGFzc2VzLCBjbGFzc2VzRGVmYXVsdCk7XG4gIGNvbnN0IHRyY2IgPSBuZXcgQ2xhc3NCdWlsZGVyKHRyYWNrQ2xhc3NlcywgdHJhY2tDbGFzc2VzRGVmYXVsdCk7XG4gIGNvbnN0IHRoY2IgPSBuZXcgQ2xhc3NCdWlsZGVyKHRodW1iQ2xhc3NlcywgdGh1bWJDbGFzc2VzRGVmYXVsdCk7XG4gIGNvbnN0IGxjYiA9IG5ldyBDbGFzc0J1aWxkZXIobGFiZWxDbGFzc2VzLCBsYWJlbENsYXNzZXNEZWZhdWx0KTtcblxuICAkOiBjID0gY2JcbiAgICAuZmx1c2goKVxuICAgIC5hZGQoY2xhc3NlcywgdHJ1ZSwgY2xhc3Nlc0RlZmF1bHQpXG4gICAgLmFkZCgkJHByb3BzLmNsYXNzKVxuICAgIC5nZXQoKTtcbiAgJDogdHIgPSB0cmNiXG4gICAgLmZsdXNoKClcbiAgICAuYWRkKFwiYmctZ3JheS03MDBcIiwgIXZhbHVlKVxuICAgIC5hZGQoYGJnLSR7Y29sb3J9LTIwMGAsIHZhbHVlKVxuICAgIC5hZGQodHJhY2tDbGFzc2VzLCB0cnVlLCB0cmFja0NsYXNzZXNEZWZhdWx0KVxuICAgIC5nZXQoKTtcbiAgJDogdGggPSB0aGNiXG4gICAgLmZsdXNoKClcbiAgICAuYWRkKHRodW1iQ2xhc3NlcywgdHJ1ZSwgdGh1bWJDbGFzc2VzRGVmYXVsdClcbiAgICAuYWRkKFwiYmctd2hpdGUgbGVmdC0wXCIsICF2YWx1ZSlcbiAgICAuYWRkKGBiZy0ke2NvbG9yfS00MDBgLCB2YWx1ZSlcbiAgICAuZ2V0KCk7XG4gICQ6IGwgPSBsY2JcbiAgICAuZmx1c2goKVxuICAgIC5hZGQobGFiZWxDbGFzc2VzLCB0cnVlLCBsYWJlbENsYXNzZXNEZWZhdWx0KVxuICAgIC5hZGQoXCJ0ZXh0LWdyYXktNTAwXCIsIGRpc2FibGVkKVxuICAgIC5hZGQoXCJ0ZXh0LWdyYXktNzAwXCIsICFkaXNhYmxlZClcbiAgICAuZ2V0KCk7XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG5cbiAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9e2N9IG9uOmNsaWNrPXtjaGVja30+XG4gIDxpbnB1dCBiaW5kOnZhbHVlIGNsYXNzPVwiaGlkZGVuXCIgdHlwZT1cImNoZWNrYm94XCIgb246Y2hhbmdlIC8+XG4gIDxkaXYgY2xhc3M9e3RyfT5cbiAgICA8ZGl2IGNsYXNzPVwidy1mdWxsIGgtZnVsbCBhYnNvbHV0ZVwiIC8+XG4gICAgPFJpcHBsZSBjb2xvcj17dmFsdWUgJiYgIWRpc2FibGVkID8gY29sb3IgOiAnZ3JheSd9IG5vSG92ZXI+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPXt0aH1cbiAgICAgICAgc3R5bGU9e3ZhbHVlID8gJ2xlZnQ6IDEuMjVyZW0nIDogXCJcIn0gLz5cbiAgICA8L1JpcHBsZT5cbiAgPC9kaXY+XG4gIDxsYWJlbCBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz17bH0+XG4gICAge2xhYmVsfVxuICA8L2xhYmVsPlxuPC9kaXY+XG4iXSwibmFtZXMiOlsiY3JlYXRlUmlwcGxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvRUFpQmUsR0FBTyxJQUFDLEtBQUsscUZBQWtFLEdBQU8sTUFBRyxFQUFFLGtCQUFHLEdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpSUFBeEcsR0FBTyxJQUFDLEtBQUsscUZBQWtFLEdBQU8sTUFBRyxFQUFFLGtCQUFHLEdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhCMUcsS0FBSyxHQUFHLFNBQVM7T0FDakIsT0FBTyxHQUFHLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFHdkIsTUFBTSxHQUFHQSxDQUFZLENBQUMsS0FBSyxFQUFFLElBQUk7Ozs7b0JBQ2pDLFVBQVUsZUFBZSxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNDMkRwQixHQUFFO3NEQUNGLEdBQUssTUFBRyxlQUFlLEdBQUcsRUFBRTs7Ozs7Ozs7a0NBRDVCLEdBQUU7OzsrRUFDRixHQUFLLE1BQUcsZUFBZSxHQUFHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBSHhCLEdBQUsscUJBQUssR0FBUTtnQkFBRyxHQUFLO01BQUcsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFPakQsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRDQUFMLEdBQUs7Ozs7Ozs7Ozs7O2tDQVRJLEdBQUU7OztvQ0FRbUIsR0FBQzs7aUNBVnhCLEdBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FBWSxHQUFLOzs7Ozs7Ozs7Ozs7OytFQUlYLEdBQUsscUJBQUssR0FBUTtlQUFHLEdBQUs7S0FBRyxNQUFNOzs7Ozs7Ozs7bUNBRnhDLEdBQUU7OzttRUFTWCxHQUFLOzs7cUNBRHlCLEdBQUM7Ozs7a0NBVnhCLEdBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFyREwsbUJBQW1CLEdBQUcseUZBQXlGO01BQy9HLG1CQUFtQixHQUFHLDREQUE0RDtNQUNsRixtQkFBbUIsR0FBRyxxQkFBcUI7OztPQUgzQyxjQUFjO09BS1QsS0FBSyxHQUFHLEtBQUs7T0FDYixLQUFLLEdBQUcsRUFBRTtPQUNWLEtBQUssR0FBRyxTQUFTO09BRWpCLFFBQVEsR0FBRyxLQUFLO09BQ2hCLFlBQVksR0FBRyxtQkFBbUI7T0FDbEMsWUFBWSxHQUFHLG1CQUFtQjtPQUNsQyxZQUFZLEdBQUcsbUJBQW1CO09BR2xDLE9BQU8sR0FBRyxjQUFjO09BRzdCLEVBQUUsT0FBTyxZQUFZLENBQUMsT0FBTyxFQUFFLGNBQWM7T0FDN0MsSUFBSSxPQUFPLFlBQVksQ0FBQyxZQUFZLEVBQUUsbUJBQW1CO09BQ3pELElBQUksT0FBTyxZQUFZLENBQUMsWUFBWSxFQUFFLG1CQUFtQjtPQUN6RCxHQUFHLE9BQU8sWUFBWSxDQUFDLFlBQVksRUFBRSxtQkFBbUI7O1VBMEJyRCxLQUFLO01BQ1IsUUFBUTtrQkFFWixLQUFLLElBQUksS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkEzQmIsQ0FBQyxHQUFHLEVBQUUsQ0FDTixLQUFLLEdBQ0wsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUNqQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFDakIsR0FBRzs7O29CQUNILEVBQUUsR0FBRyxJQUFJLENBQ1QsS0FBSyxHQUNMLEdBQUcsQ0FBQyxhQUFhLEdBQUcsS0FBSyxFQUN6QixHQUFHLE9BQU8sS0FBSyxRQUFRLEtBQUssRUFDNUIsR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQzNDLEdBQUc7Ozs7b0JBQ0gsRUFBRSxHQUFHLElBQUksQ0FDVCxLQUFLLEdBQ0wsR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQzNDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLEVBQzdCLEdBQUcsT0FBTyxLQUFLLFFBQVEsS0FBSyxFQUM1QixHQUFHOzs7O29CQUNILENBQUMsR0FBRyxHQUFHLENBQ1AsS0FBSyxHQUNMLEdBQUcsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUMzQyxHQUFHLENBQUMsZUFBZSxFQUFFLFFBQVEsRUFDN0IsR0FBRyxDQUFDLGVBQWUsR0FBRyxRQUFRLEVBQzlCLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
